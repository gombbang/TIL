TDD
TDD 자체가 그냥 개발 테스트 자체를 뒤집어 버리는거였지
Production Code -> Test, 테스트는 보조수단
Production Code <-> Test, 테스트의 중요도가 올라가 구현부와 상호작용하는 정책.
클라이언트 관점에서 피드백을 주는 것이 Test Driven 같다.
	내가 만든 객체를 생성 메서드호출등을 하는 클라이언트 관점에서 피드백을 줄 수 있는
	사용하는 입장에서

Red > Green > Refacotr 단계
Red : 시나리오에 맞게 테스트 쭉 만들어두고 개발은 없으니 다 실패해서 Red
Green : 막 만들어도 되니까 일단 테스트 통과만 되면 된다.
Refactor : 구현 코드 개선

---

난 아직 Green 단계인 것 같은데 벌써 배포단계라고..?

---
Test 를 통한 기능 보장을 통해 refactor를 해도 무방하게 된다.
**Test가 잘 만들어져야한다는 조건이 있다.**

기한이 부족해서 테스트 자체를 만들 시간이 없다.
> 유지보수 어려워짐

해피케이스만 검증할 가능성
> 실패 케이스에 대한 검증이 놓쳐질 수 있다.

테스트를 나중에 짜면, 구현이 잘못된 것을 나중에 발견한다는 문제도 발생한다.

### 선 테스트를 만들어라!

복잡도가 낮은, 테스트 가능한 코드로 구현할 수 있게 한다.
> 유연하고 유지보수가 쉬운

* Local Date Time은 테스트하기 어려우므로 외부로 분리해서 별도로 처리해야한다.
* LocalDateTime . now로 해서, 해당 shop이 열고있는 시간이 아니면, 주문할 수 없는 시간입니다 라는 형태로 전달을 한다거나 하는 내용..

선 테스트 구조로 하면
	아 이거 어렵네, 그럼 안해야지 가 아니라
	**테스트하기 좋은 구조로 먼저 생각하고 처리**해서, 테스트가 가능한 코드로 구현할 수 있다.

	엣지케이스 처리
	구현부에 대한 빠른 피드백
	과감한 리팩토링

폭포수 ~ 애자일 ~ 익스트림 프로그래밍 (여기에 TDD가 있다.)

---
---
Test는 [문서]다.
	기능을 설명한다.
	테스트 케이스로 코드를 이해하는 시각과 관점 보완 (시나리오, 전체적 관점에서 쓰이는 의미)
	기능에 대한 개발자의 고민한 결과물을 자산으로 공유할 수 있다.

---
테스트 명의 애노테이션, DisplayName
	DisplayName으로 비즈니스 코드와 기본 지식이 없다고 했을 때, 이 내용으로 확인이 더 섬세하게 된다.
**문장형으로 적자**
**테스트행위에 대한 결과까지 기술**
**도메인 용어로 구체화**
	**메서드 자체의 관점보다는 도메인 정책 관점으로**
		특정시간 이전에 실패한다 -> 영업시작 시간 전에는 생성불가 (도메인 용어)
	**테스트 현상을 중점으로 기술하지 말기**
		실패한다 대신에 생성할 수 없다 라는 형태로 (도메인 정책 관점)
#DisplayName 


---
---
BDD, Behavior Driven Development

함수라는 테스트 대신 함수보다 그 함수가 어떤 역할을 해야하는지 
> **특정 시나리오에 대한 테스트를 작성하자** (TC, Test Case)

개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 레벨 권장

이게 바로~~
Given / When / Then
---
---
Given : 객체, 값,상태 등 준비과정
When : 시나리오 행동 진행
Then : 시나리오에 대한 결과 명시, 검증

어떤 환경에서
어떤 행동을 진행했을 때
어떤 상태변화가 일어난다.
DisplayName에 명확하게 작성 가능
#DisplayName

## 쉽게 만들어두기
IntelliJ Setting > 검색 > live templates
+버튼 > test 템플릿 > 

	@org.junit.jupiter.api.DisplayName("")
	@org.junit.jupiter.api.Test
	void test() {
	// given
	
	// when
	
	// then
	}
---
Spock
- grovy 언어 framework
- BDD 기반
